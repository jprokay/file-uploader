// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package api

import (
	"context"
	"encoding/json"
	"fmt"
	"mime/multipart"
	"net/http"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for DirectoryDirectoryStatus.
const (
	DirectoryDirectoryStatusCompleted  DirectoryDirectoryStatus = "completed"
	DirectoryDirectoryStatusError      DirectoryDirectoryStatus = "error"
	DirectoryDirectoryStatusProcessing DirectoryDirectoryStatus = "processing"
)

// Defines values for GetAllDirectoriesParamsSort.
const (
	Asc  GetAllDirectoriesParamsSort = "asc"
	Desc GetAllDirectoriesParamsSort = "desc"
)

// Defines values for CreateNewDirectoryMultipartBodyColumnLayout.
const (
	Email     CreateNewDirectoryMultipartBodyColumnLayout = "email"
	FirstName CreateNewDirectoryMultipartBodyColumnLayout = "first_name"
	LastName  CreateNewDirectoryMultipartBodyColumnLayout = "last_name"
)

// ArrayOfDirectoryErrors defines model for ArrayOfDirectoryErrors.
type ArrayOfDirectoryErrors = []struct {
	Error    *string `json:"error,omitempty"`
	FileName *string `json:"fileName,omitempty"`
}

// Contact defines model for Contact.
type Contact struct {
	ContactEmail     string `json:"contact_email"`
	ContactFirstName string `json:"contact_first_name"`
	ContactId        string `json:"contact_id"`
	ContactLastName  string `json:"contact_last_name"`
	UserId           string `json:"user_id"`
}

// ContactsWithTotal defines model for ContactsWithTotal.
type ContactsWithTotal struct {
	Items []Contact `json:"items"`
	Total int       `json:"total"`
}

// DirectoriesWithTotal defines model for DirectoriesWithTotal.
type DirectoriesWithTotal struct {
	Items []Directory `json:"items"`
	Total int         `json:"total"`
}

// Directory defines model for Directory.
type Directory struct {
	DirectoryCreatedAt string                   `json:"directory_created_at"`
	DirectoryEntries   int                      `json:"directory_entries"`
	DirectoryId        int                      `json:"directory_id"`
	DirectoryName      string                   `json:"directory_name"`
	DirectoryStatus    DirectoryDirectoryStatus `json:"directory_status"`
	UserId             openapi_types.UUID       `json:"user_id"`
}

// DirectoryDirectoryStatus defines model for Directory.DirectoryStatus.
type DirectoryDirectoryStatus string

// DirectoryEntry defines model for DirectoryEntry.
type DirectoryEntry struct {
	DirectoryId     int    `json:"directory_id"`
	EntryEmail      string `json:"entry_email"`
	EntryEmailValid bool   `json:"entry_email_valid"`
	EntryFirstName  string `json:"entry_first_name"`
	EntryId         int    `json:"entry_id"`
	EntryLastName   string `json:"entry_last_name"`
	OrderId         int    `json:"order_id"`
	UserId          string `json:"user_id"`
}

// EntriesWithTotal defines model for EntriesWithTotal.
type EntriesWithTotal struct {
	Items []DirectoryEntry `json:"items"`
	Total int              `json:"total"`
}

// Error defines model for Error.
type Error struct {
	Error *string `json:"error,omitempty"`
}

// ServerError defines model for ServerError.
type ServerError = Error

// GetAllContactsParams defines parameters for GetAllContacts.
type GetAllContactsParams struct {
	Limit  int     `form:"limit" json:"limit"`
	Offset int     `form:"offset" json:"offset"`
	Search *string `form:"search,omitempty" json:"search,omitempty"`
	UserId string  `form:"userId" json:"userId"`
}

// GetAllDirectoriesParams defines parameters for GetAllDirectories.
type GetAllDirectoriesParams struct {
	Sort   *GetAllDirectoriesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
	Limit  int                          `form:"limit" json:"limit"`
	Offset int                          `form:"offset" json:"offset"`
	UserId string                       `form:"userId" json:"userId"`
}

// GetAllDirectoriesParamsSort defines parameters for GetAllDirectories.
type GetAllDirectoriesParamsSort string

// CreateNewDirectoryMultipartBody defines parameters for CreateNewDirectory.
type CreateNewDirectoryMultipartBody struct {
	ColumnLayout    []CreateNewDirectoryMultipartBodyColumnLayout `json:"columnLayout"`
	ExcludeFirstRow bool                                          `json:"excludeFirstRow"`
	Filename        *[]openapi_types.File                         `json:"filename,omitempty"`
}

// CreateNewDirectoryParams defines parameters for CreateNewDirectory.
type CreateNewDirectoryParams struct {
	UserId string `form:"userId" json:"userId"`
}

// CreateNewDirectoryMultipartBodyColumnLayout defines parameters for CreateNewDirectory.
type CreateNewDirectoryMultipartBodyColumnLayout string

// GetEntriesForDirectoryParams defines parameters for GetEntriesForDirectory.
type GetEntriesForDirectoryParams struct {
	Limit  int     `form:"limit" json:"limit"`
	Offset int     `form:"offset" json:"offset"`
	Search *string `form:"search,omitempty" json:"search,omitempty"`
	UserId string  `form:"userId" json:"userId"`
}

// CreateNewDirectoryMultipartRequestBody defines body for CreateNewDirectory for multipart/form-data ContentType.
type CreateNewDirectoryMultipartRequestBody CreateNewDirectoryMultipartBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Authenticate
	// (GET /auth)
	GetAuthenticate(ctx echo.Context) error
	// Get all Contacts
	// (GET /contacts)
	GetAllContacts(ctx echo.Context, params GetAllContactsParams) error
	// Get all uploaded Directories
	// (GET /directories)
	GetAllDirectories(ctx echo.Context, params GetAllDirectoriesParams) error
	// Upload a new Directory
	// (POST /directories)
	CreateNewDirectory(ctx echo.Context, params CreateNewDirectoryParams) error
	// Get Directory Entries for a Directory
	// (GET /directories/{id}/entries)
	GetEntriesForDirectory(ctx echo.Context, id int, params GetEntriesForDirectoryParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAuthenticate converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthenticate(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAuthenticate(ctx)
	return err
}

// GetAllContacts converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllContacts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllContactsParams
	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	if cookie, err := ctx.Cookie("userId"); err == nil {

		var value string
		err = runtime.BindStyledParameterWithOptions("simple", "userId", cookie.Value, &value, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationCookie, Explode: true, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
		}
		params.UserId = value

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument userId is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllContacts(ctx, params)
	return err
}

// GetAllDirectories converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllDirectories(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllDirectoriesParams
	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	if cookie, err := ctx.Cookie("userId"); err == nil {

		var value string
		err = runtime.BindStyledParameterWithOptions("simple", "userId", cookie.Value, &value, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationCookie, Explode: true, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
		}
		params.UserId = value

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument userId is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllDirectories(ctx, params)
	return err
}

// CreateNewDirectory converts echo context to params.
func (w *ServerInterfaceWrapper) CreateNewDirectory(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateNewDirectoryParams

	if cookie, err := ctx.Cookie("userId"); err == nil {

		var value string
		err = runtime.BindStyledParameterWithOptions("simple", "userId", cookie.Value, &value, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationCookie, Explode: true, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
		}
		params.UserId = value

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument userId is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateNewDirectory(ctx, params)
	return err
}

// GetEntriesForDirectory converts echo context to params.
func (w *ServerInterfaceWrapper) GetEntriesForDirectory(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntriesForDirectoryParams
	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	if cookie, err := ctx.Cookie("userId"); err == nil {

		var value string
		err = runtime.BindStyledParameterWithOptions("simple", "userId", cookie.Value, &value, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationCookie, Explode: true, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
		}
		params.UserId = value

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument userId is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEntriesForDirectory(ctx, id, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/auth", wrapper.GetAuthenticate)
	router.GET(baseURL+"/contacts", wrapper.GetAllContacts)
	router.GET(baseURL+"/directories", wrapper.GetAllDirectories)
	router.POST(baseURL+"/directories", wrapper.CreateNewDirectory)
	router.GET(baseURL+"/directories/:id/entries", wrapper.GetEntriesForDirectory)

}

type DirectoryJSONResponse Directory

type ServerErrorJSONResponse Error

type GetAuthenticateRequestObject struct {
}

type GetAuthenticateResponseObject interface {
	VisitGetAuthenticateResponse(w http.ResponseWriter) error
}

type GetAuthenticate200JSONResponse map[string]interface{}

func (response GetAuthenticate200JSONResponse) VisitGetAuthenticateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetAllContactsRequestObject struct {
	Params GetAllContactsParams
}

type GetAllContactsResponseObject interface {
	VisitGetAllContactsResponse(w http.ResponseWriter) error
}

type GetAllContacts200JSONResponse ContactsWithTotal

func (response GetAllContacts200JSONResponse) VisitGetAllContactsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetAllDirectoriesRequestObject struct {
	Params GetAllDirectoriesParams
}

type GetAllDirectoriesResponseObject interface {
	VisitGetAllDirectoriesResponse(w http.ResponseWriter) error
}

type GetAllDirectories200JSONResponse DirectoriesWithTotal

func (response GetAllDirectories200JSONResponse) VisitGetAllDirectoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetAllDirectories500JSONResponse struct{ ServerErrorJSONResponse }

func (response GetAllDirectories500JSONResponse) VisitGetAllDirectoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateNewDirectoryRequestObject struct {
	Params CreateNewDirectoryParams
	Body   *multipart.Reader
}

type CreateNewDirectoryResponseObject interface {
	VisitCreateNewDirectoryResponse(w http.ResponseWriter) error
}

type CreateNewDirectory200JSONResponse struct{ DirectoryJSONResponse }

func (response CreateNewDirectory200JSONResponse) VisitCreateNewDirectoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreateNewDirectory500JSONResponse struct {
	Completed *DirectoriesWithTotal   `json:"completed,omitempty"`
	Errors    *ArrayOfDirectoryErrors `json:"errors,omitempty"`
}

func (response CreateNewDirectory500JSONResponse) VisitCreateNewDirectoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetEntriesForDirectoryRequestObject struct {
	Id     int `json:"id"`
	Params GetEntriesForDirectoryParams
}

type GetEntriesForDirectoryResponseObject interface {
	VisitGetEntriesForDirectoryResponse(w http.ResponseWriter) error
}

type GetEntriesForDirectory200JSONResponse EntriesWithTotal

func (response GetEntriesForDirectory200JSONResponse) VisitGetEntriesForDirectoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Authenticate
	// (GET /auth)
	GetAuthenticate(ctx context.Context, request GetAuthenticateRequestObject) (GetAuthenticateResponseObject, error)
	// Get all Contacts
	// (GET /contacts)
	GetAllContacts(ctx context.Context, request GetAllContactsRequestObject) (GetAllContactsResponseObject, error)
	// Get all uploaded Directories
	// (GET /directories)
	GetAllDirectories(ctx context.Context, request GetAllDirectoriesRequestObject) (GetAllDirectoriesResponseObject, error)
	// Upload a new Directory
	// (POST /directories)
	CreateNewDirectory(ctx context.Context, request CreateNewDirectoryRequestObject) (CreateNewDirectoryResponseObject, error)
	// Get Directory Entries for a Directory
	// (GET /directories/{id}/entries)
	GetEntriesForDirectory(ctx context.Context, request GetEntriesForDirectoryRequestObject) (GetEntriesForDirectoryResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// GetAuthenticate operation middleware
func (sh *strictHandler) GetAuthenticate(ctx echo.Context) error {
	var request GetAuthenticateRequestObject

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetAuthenticate(ctx.Request().Context(), request.(GetAuthenticateRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAuthenticate")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(GetAuthenticateResponseObject); ok {
		return validResponse.VisitGetAuthenticateResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetAllContacts operation middleware
func (sh *strictHandler) GetAllContacts(ctx echo.Context, params GetAllContactsParams) error {
	var request GetAllContactsRequestObject

	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetAllContacts(ctx.Request().Context(), request.(GetAllContactsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAllContacts")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(GetAllContactsResponseObject); ok {
		return validResponse.VisitGetAllContactsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetAllDirectories operation middleware
func (sh *strictHandler) GetAllDirectories(ctx echo.Context, params GetAllDirectoriesParams) error {
	var request GetAllDirectoriesRequestObject

	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetAllDirectories(ctx.Request().Context(), request.(GetAllDirectoriesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAllDirectories")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(GetAllDirectoriesResponseObject); ok {
		return validResponse.VisitGetAllDirectoriesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreateNewDirectory operation middleware
func (sh *strictHandler) CreateNewDirectory(ctx echo.Context, params CreateNewDirectoryParams) error {
	var request CreateNewDirectoryRequestObject

	request.Params = params

	if reader, err := ctx.Request().MultipartReader(); err != nil {
		return err
	} else {
		request.Body = reader
	}

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateNewDirectory(ctx.Request().Context(), request.(CreateNewDirectoryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateNewDirectory")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(CreateNewDirectoryResponseObject); ok {
		return validResponse.VisitCreateNewDirectoryResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetEntriesForDirectory operation middleware
func (sh *strictHandler) GetEntriesForDirectory(ctx echo.Context, id int, params GetEntriesForDirectoryParams) error {
	var request GetEntriesForDirectoryRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetEntriesForDirectory(ctx.Request().Context(), request.(GetEntriesForDirectoryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetEntriesForDirectory")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(GetEntriesForDirectoryResponseObject); ok {
		return validResponse.VisitGetEntriesForDirectoryResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}
